import PropositionSchedulerBuilder from "./proposition_scheduler/PropositionSchedulerBuilder.js"
import Proposition from "./proposition/Proposition.js"
import UserProgress from "../utilities/UserProgress.js"

/**
 * A lesson is mainly a list of Propositions.
 * The constructor takes the json generated by a LessonBuilder.
 */
export default class Lesson {

    constructor(jsonData) {
        this.jsonData = jsonData
        this.metadata = jsonData.metadata
        this.explanationText = jsonData.explanation.text

        this.propositions = jsonData.propositions.map(p => { return new Proposition(p) })
        this.scheduler = PropositionSchedulerBuilder.getScheduler(this.getId(), this.propositions)
    }

    /**
     * Point to the next proposition.
     * Decide if the lesson is over or not
     */
    next() {
        this.scheduler.next()
    }

    /**
     * Get the current Proposition.
     * @returns Proposition
     */
    getCurrent() {
        return this.scheduler.getCurrent()
    }

    /**
     * Is this lesson over yet?
     * @returns boolean
     */
    isOver() {
        let over = this.scheduler.isOver()
        over? UserProgress.saveLessonScore(this.getId(), this.dumpScores()) : ""
        return over
    }

    /**
     * Get average score.
     * @returns {number}
     */
    getScore() {
        return parseInt(this.propositions.map((p) => { return p.getScore() }).reduce((a, b) => { return a + b }) / this.propositions.length)
    }


    //TODO: better looking id
    /**
     * Nominally identifies a Lesson.
     * @returns {string}
     */
    getId(){
        return this.metadata.author + this.metadata.target_language + this.metadata.source_language + this.metadata.title 
    }

     /**
     * Dumps info relative to the user's performance with this Lesson.
     * 
     * ```json
     * {
     * "last_taken" : unix epoch timestamp,
     * "overall" : overall score,
     * "propositions" : [ [propoHash1, score1], [propoHash2, score2]  ]
     * }
     * ```
     * 
     * @returns 
     */
      dumpScores() {

        return {
            "last_taken": new Date().getTime(),
            "overall": this.getScore(),
            "propositions": this.propositions.map((p) => { return [p.getHash(), p.getScore()] })
        }

    }


    
}
