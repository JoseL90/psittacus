import PropositionSchedulerBuilder from "./proposition_scheduler/PropositionSchedulerBuilder.js"
import Proposition from "./proposition/Proposition.js"
import UserProgress from "../utilities/UserProgress.js"
import Database from "../utilities/Database.js"

/**
 * A lesson contains a list of Propositions.
 * The constructor takes the json generated by `LessonBuilder`.
 */
export default class Lesson {

    constructor(jsonData) {
        this.jsonData = jsonData
        this.metadata = jsonData.metadata
        this.explanationText = jsonData.explanation.text
        this.propositions = jsonData.propositions.map(p => { return new Proposition(p) })
        this.scheduler = PropositionSchedulerBuilder.getScheduler(this.getId(), this.propositions)
    }

    /**
     * Point to the next proposition.
     * Decide if the lesson is over or not
     */
    next() {
        this.scheduler.next()
    }

    /**
     * Get the current Proposition.
     * @returns Proposition
     */
    getCurrent() {
        return this.scheduler.getCurrent()
    }

    /**
     * Is this lesson over yet?
     * @returns boolean
     */
    isOver() {
        let over = this.scheduler.isOver()

        //if this lesson is over, save the score
        if(over){
            UserProgress.saveLessonScore(this.getId(), this.dumpScores()) 
            this.cacheLesson() 
        }

        return over
    }

    /**
     * Get average score.
     * @returns {number}
     */
    getScore() {
        return parseInt(this.propositions.map((p) => { return p.getScore() }).reduce((a, b) => { return a + b }) / this.propositions.length)
    }


    //TODO: better looking id
    /**
     * Nominally identifies a Lesson.
     * @returns {string}
     */
    getId() {
        return this.metadata.author + this.metadata.target_language + this.metadata.source_language + this.metadata.title
    }

    /**
    * Dumps info relative to the user's performance with this Lesson.
    * 
    * ```json
    * {
    * "last_taken" : unix epoch timestamp,
    * "overall" : overall score,
    * "propositions" : [ [propoHash1, score1], [propoHash2, score2]  ]
    * }
    * ```
    * 
    * @returns 
    */
    dumpScores() {

        return {
            "last_taken": new Date().getTime(),
            "overall": this.getScore(),
            "propositions": this.propositions.map((p) => { return [p.getHash(), p.getScore()] })
        }

    }

    /**
     * Cache this Lesson, overwriting it in case of conflicting ids.
     */
    async cacheLesson() {
        
        await Database.get().cachedLessons().delete(this.getId())
        // console.log(`Deleted lesson with id=${this.getId()}`)
        // console.log(await Database.get().cachedLessons().toArray())

        /*await*/ Database.get().cachedLessons().add({
            id: this.getId(),
            lesson: this.jsonData
        })

        // console.log(await Database.get().cachedLessons().toArray())
        // console.log(`Cached lesson with id=${this.getId()}`)

    }

    /**
     * Load a previously cached Lesson on the DB back into memory. 
     * @param {string} id 
     * @returns {Promise<Lesson>}
     */
    static async getCachedLessonById(id){
        let record = await Database.get().cachedLessons().get(id)
        return new Lesson(record.lesson)
    }
    
}




